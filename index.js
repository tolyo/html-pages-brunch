'use strict';

const minify = require('html-minifier').minify;
const sysPath = require('path');
const mkdirp = require('mkdirp');
const fs = require('fs');
const fm = require('front-matter');

const DEFAULT_PATTERN = /\.html$/;
const DEFAULT_HTMLMIN_OPTIONS = {
  caseSensitive: false,
  collapseBooleanAttributes: true,
  collapseInlineTagWhitespace: false,
  collapseWhitespace: true,
  conservativeCollapse: false,
  html5: true,
  includeAutoGeneratedTags: false,
  keepClosingSlash: false,
  minifyCSS: true,
  minifyJS: true,
  preserveLineBreaks: false,
  preventAttributesEscaping: false,
  processConditionalComments: true,
  removeAttributeQuotes: true,
  removeComments: true,
  removeEmptyAttributes: true,
  removeOptionalTags: true,
  removeScriptTypeAttributes: true,
  removeStyleLinkTypeAttributes: true,
  sortAttributes: true,
  sortClassName: true
};

const DEFAULT_DESTINATION_FN = path => {
  return path.replace(/^app[\/\\]/, '');
};
const DEFAULT_FRONT_MATTER_SEPARATOR = '---';

const performMinify = (htmlPages, data) => {
  if (htmlPages.disabled) {
    if (htmlPages.forceRemoveFrontMatter) {
      const frontmatter = fm(data);
      return frontmatter.body;
    } else {
      return data;
    }
  } else {
    if (!htmlPages.preserveFrontMatter && !htmlPages.removeFrontMatter) {
      return minify(data, htmlPages.htmlMinOptions);
    } else {
      if (htmlPages.removeFrontMatter) {
        // strip out front matter
        const frontmatter = fm(data);
        return minify(frontmatter.body, htmlPages.htmlMinOptions);
      } else {
        // minify and add back front matter
        const frontmatter = fm(data);
        return htmlPages.frontMatterSeparator + '\n' +
          frontmatter.frontmatter + '\n' +
          htmlPages.frontMatterSeparator + '\n' +
          minify(frontmatter.body, htmlPages.htmlMinOptions);
      }
    }
  }
};

class HtmlPages {
  constructor(config) {
    if (config === undefined) config = {};
    if (config.plugins === undefined) config.plugins = {};

    const pluginConfig = config.plugins.htmlPages || {};
    this.publicPath = config.paths.public;
    this.destinationFn = pluginConfig.destination || DEFAULT_DESTINATION_FN;
    this.disabled = !config.optimize || pluginConfig.disabled;
    this.pattern = pluginConfig.pattern || DEFAULT_PATTERN;
    this.forceRemoveFrontMatter = !!pluginConfig.forceRemoveFrontMatter;
    this.removeFrontMatter = this.forceRemoveFrontMatter || !!pluginConfig.removeFrontMatter;
    this.preserveFrontMatter = !!pluginConfig.preserveFrontMatter;
    this.frontMatterSeparator = pluginConfig.frontMatterSeparator || DEFAULT_FRONT_MATTER_SEPARATOR;
    this.htmlMinOptions = pluginConfig.htmlMin ?
      Object.assign({}, pluginConfig.htmlMin) :
      DEFAULT_HTMLMIN_OPTIONS;
    this.compileAssets = pluginConfig.compileAssets;
  }

  compile(file, path, callback) {
    let err, error;
    try {
      const result = performMinify(this, file);
      const destinationPath = sysPath.join(this.publicPath, this.destinationFn(path));
      const destinationDir = sysPath.dirname(destinationPath);
      mkdirp.sync(destinationDir);
      return fs.writeFileSync(destinationPath, result);
    } catch (_error) {
      err = _error;
      console.error('Error while processing \'${path}\': ${err.toString()}');
      return error = err;
    } finally {
      return callback(error, '');
    }
  }

  compileStatic(file) {
    const data = file.data;
    const path = file.path;

    return new Promise(resolve => {
      resolve({
        data: this.compileAssets ? performMinify(this, data) : data,
        path: sysPath.join(this.publicPath, this.destinationFn(path))
      });
    });
  }
}

HtmlPages.prototype.brunchPlugin = true;
HtmlPages.prototype.type = 'template';
HtmlPages.prototype.extension = 'html';
HtmlPages.prototype.staticTargetExtension = 'html';

module.exports = HtmlPages;
